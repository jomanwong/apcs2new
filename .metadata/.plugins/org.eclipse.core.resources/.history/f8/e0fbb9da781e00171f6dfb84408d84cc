package textExcel;

public class FormulaCell extends RealCell {

	private String userInput; // ( * + * )

	public FormulaCell(String in) {
		super(in);
		this.userInput = in;
		// TODO Auto-generated constructor stub
	}

	@Override
	public String abbreviatedCellText(){ //TODO: use recursion that calls itself when method is entered.
		//It checks the value of the cell it references, aka set value again.
		String abbreviatedText = getDoubleValue(userInput) + "";

		if(abbreviatedText.length() > 10){    

			abbreviatedText = userInput.substring(0, 10);
			return abbreviatedText;

		}else{
			//autofill spaces
			while(abbreviatedText.length() < 10){

				abbreviatedText += " ";

			}

			return abbreviatedText;
		}
	}

	public String fullCellText() {
		return getDoubleValue(userInput) + "";
	}

	public String inspectCell(String cell){
		//returns content of cell
		SpreadsheetLocation loc = new SpreadsheetLocation(cell); //thx to Mr DeHeer pointing out I could use SpreedsheetLocation
		return getCell(loc).fullCellText();
	}

	public Cell getCell(Location loc){
		// TODO Auto-generated method stub
		return Spreadsheet.spreadSheet [loc.getRow()][loc.getCol()]; //note to self, notice method returns type Cell, not String
	}


	@Override //what about order of operations?
	//Handling zeroes? - solved as add or subtract from zeroes doesn't change, multi by 0 = 0, but, can't divide from zero
	public double getDoubleValue(String in){
		String str = in.substring(2, in.length() - 3);
		String [] inParts = str.split(" "); //split at spaces, results in [#][+][#] //BUT WHAT IF IT'S JUST 1 NUMBER ( # ) -> [#]
		double returnThis = Double.parseDouble(inParts[0]);	//first number of formula
		if(inParts.length <= 3){
			if(inParts[1].equals("+")) { 					//addition 
				returnThis += Double.valueOf(inParts[2]);
			}else if(inParts[1].equals("-")) { 				//subtraction
				returnThis -= Double.valueOf(inParts[2]);
			}else if(inParts[1].equals("*")) { 				//multiplication
				returnThis *= Double.valueOf(inParts[2]);
			}else{
				if(inParts[1].equals("/")) { 				//division (honestly, as last choice it doesn't need to check if, but a good error catch...
					//if there are no other number or formula.
					returnThis /= Double.valueOf(inParts[2]);
				}
			}
		}else{
			for(int i = 0; i < inParts.length - 1; i += 2){ //first, then skips the operation sign 
				//Then, check operations, until end
				if(inParts[i + 1].equals("+")) { 					//addition 
					returnThis += Double.valueOf(inParts[i + 2]);
				}else if(inParts[i + 1].equals("-")) { 				//subtraction
					returnThis -= Double.valueOf(inParts[i + 2]);
				}else if(inParts[i + 1].equals("*")) { 				//multiplication
					returnThis *= Double.valueOf(inParts[i + 2]);
				}else{
					if(inParts[i + 1].equals("/")) { 				//division (honestly, as last choice it doesn't need to check if, but a good error catch...
						//if there are no other number or formula.
						returnThis /= Double.valueOf(inParts[i + 2]);
					}
				}
			}
		}
		return returnThis;
	}

}
